(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function e(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=e(i);fetch(i.href,r)}})();class c{constructor(){this.maxHp=10,this.force=3,this.hp=this.maxHp,this.xp=0,this._x=0,this._y=0}gainXP(t){this.xp+=t,console.log(`+${t} XP (Total: ${this.xp})`)}get position(){return{x:this._x,y:this._y}}setPosition(t){this._x=t.x,this._y=t.y}spawn(t,e){t[this._y][this._x]="player",e.updateCell(this._x,this._y,"player")}}class n{constructor(){this.name="Goblin",this.hp=3,this.force=2,this.xpValue=1,this.type="goblin"}}class p{constructor(){this.name="Ogre",this.hp=6,this.force=3,this.xpValue=3,this.type="ogre"}}class d{static _getEmptyCells(t){const e=[];for(let s=0;s<t.length;s++)for(let i=0;i<t[s].length;i++)t[s][i]||e.push({x:i,y:s});return e}static _shuffleAndSelect(t){let e=Math.min(t.length,Math.floor(Math.random()*41)+10);for(let s=t.length-1;s>0;s--){const i=Math.floor(Math.random()*(s+1));[t[s],t[i]]=[t[i],t[s]]}return t.slice(0,e)}static spawn(t,e){const s=this._getEmptyCells(t);this._shuffleAndSelect(s).forEach(({x:r,y:o})=>{const h=this._getRandomMonsterType(),l=new h;t[o][r]=l,e.updateCell(r,o,l.type)})}static _getRandomMonsterType(){const t=[n,n,n,p];return t[Math.floor(Math.random()*t.length)]}}class u{constructor(t,e,s){this.player=t,this.stateMatrix=e,this.onMove=s}initArrowListeners(){document.querySelectorAll(".arrow-btn").forEach(t=>{t.addEventListener("click",e=>{const s=e.target.dataset.direction;this.handleMove(s)})})}handleMove(t){const e=this._calculateNewPosition(t);this._isValidPosition(e)&&this._updatePosition(e)}_calculateNewPosition(t){const{x:e,y:s}=this.player.position;return{up:{x:e,y:s-1},down:{x:e,y:s+1},left:{x:e-1,y:s},right:{x:e+1,y:s}}[t]}_isValidPosition(t){return t.x>=0&&t.x<8&&t.y>=0&&t.y<10}_updatePosition(t){const e=this.player.position;this.player.setPosition(t),this.onMove(e,t)}}class y{constructor(t){this.container=document.getElementById(t),this.grid=null}generateGrid(){this.grid=document.createElement("div"),this.grid.className="game-grid";for(let t=0;t<10;t++)for(let e=0;e<8;e++){const s=document.createElement("div");s.className="grid-cell",s.dataset.x=e,s.dataset.y=t,this.grid.appendChild(s)}this.container.appendChild(this.grid)}updateCell(t,e,s){const i=this.grid.querySelector(`[data-x="${t}"][data-y="${e}"]`);if(!i){console.error(`Cell not found at ${t},${e}`);return}switch(i.className="grid-cell",s){case"player":i.classList.add("player-cell");break;case"goblin":case"ogre":i.classList.add("enemy-cell",s);break;default:i.classList.add("empty-cell")}}}class m{static createArrowControls(t){const e=document.getElementById(t),s={up:"↑",left:"←",right:"→",down:"↓"};e.innerHTML=`
      <div class="controls-grid">
        <button class="arrow-btn" data-direction="up" style="grid-area: up">${s.up}</button>
        <button class="arrow-btn" data-direction="left" style="grid-area: left">${s.left}</button>
        <button class="arrow-btn" data-direction="right" style="grid-area: right">${s.right}</button>
        <button class="arrow-btn" data-direction="down" style="grid-area: down">${s.down}</button>
      </div>
    `}}class f{constructor(t,e){this.player=t,this.monster=e,this.logs=[]}resolve(){let t={victoire:!1,playerDead:!1};for(;this.player.hp>0&&this.monster.hp>0;){const e=Number(this.player.force);if(this.monster.hp-=e,this.logs.push(`Joueur attaque: ${this.monster.name} -${e}PV (reste ${this.monster.hp})`),this.monster.hp<=0)break;const s=Number(this.monster.force);this.player.hp=Math.max(this.player.hp-s,0),this.logs.push(`${this.monster.name} attaque: Joueur -${s}PV (reste ${this.player.hp})`)}return t.victoire=this.monster.hp<=0,t.playerDead=this.player.hp<=0,t.victoire&&(this.player.hp=this.player.maxHp,this.logs.push(`Victoire! Joueur soigné (${this.player.hp}/${this.player.maxHp} PV)`)),this.logs.forEach(e=>console.log(e)),console.log(t.victoire?"VICTOIRE":"GAME OVER"),t}}class g{constructor(){this.stateMatrix=Array(10).fill().map(()=>Array(8).fill(null)),this.map=new y("map"),this.player=new c,this.ui=m,this.movement=new u(this.player,this.stateMatrix,(t,e)=>this._handlePositionUpdate(t,e))}init(){this.map.generateGrid(),this.ui.createArrowControls("player-ui"),this.movement.initArrowListeners(),this._spawnEntities(),window.addEventListener("keydown",t=>this.movement.handleKeyPress(t))}_spawnEntities(){this.player.spawn(this.stateMatrix,this.map),d.spawn(this.stateMatrix,this.map)}_handlePositionUpdate(t,e){const s=this.stateMatrix[e.y][e.x];if(s!=null&&s.type)if(new f(this.player,s).resolve().victoire)this.stateMatrix[e.y][e.x]="player",this.map.updateCell(e.x,e.y,"player");else{this.player.setPosition(t),this.map.updateCell(e.x,e.y,s.type),this.map.updateCell(t.x,t.y,"player");return}this.stateMatrix[t.y][t.x]=null,this.stateMatrix[e.y][e.x]="player",this.map.updateCell(t.x,t.y,"empty"),this.map.updateCell(e.x,e.y,"player")}}const x=new g;x.init();
